<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>User Manual</title>

  <para>This chapter describes all things the users need to know about the
  templating system. This starts with a little tutorial how to write a
  template, using layouts, and finishes with writing your own view
  helpers.</para>

  <section>
    <title>How to write a template</title>

    <para>Let's look at a small example - outputting a list of all Blog
    postings:</para>

    <para><programlisting>&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Blog Posts&lt;/h2&gt;
&lt;/body&gt;</programlisting></para>

    <para>View helpers are namespaced</para>
  </section>

  <section>
    <title>Syntax Elements</title>

    <para>‚ÅÑ</para>

    <section>
      <title>ViewHelpers / Namespace declaration</title>

      <para>Most custom output logic is placed in so-called
      <emphasis>ViewHelpers</emphasis>, which can be called from inside a
      template as special tags:</para>

      <para><programlisting>{namespace f3=F3\Fluid\ViewHelpers}
&lt;f3:link action="someAction"&gt;Administration interface&lt;/f3:link&gt;</programlisting>The
      first line in the above example is the so-called <emphasis>namespace
      declaration</emphasis>, which imports a certain ViewHelper package into
      the template. Thus, <code>f3</code> is a shorthand for
      <code>F3\Fluid\ViewHelpers</code>. In the second line, we call a View
      Helper called <code>LinkViewHelper</code>, which takes the
      <code>action</code> argument, and renders a HTML link from it.</para>
    </section>

    <section>
      <title>Variables and Object Accessors</title>

      <para>A templating system would be quite pointless if it was not
      possible to display some external data in the templates. That's what
      variables are for:</para>

      <para>Suppose you want to output the title of your blog, you could write
      the following snippet into your controller:</para>

      <para><programlisting>$this-&gt;view-&gt;addVariable('blogTitle', $blog-&gt;getTitle());</programlisting>Then,
      you could output the blog title in your template with the following
      snippet:</para>

      <para><programlisting>&lt;h1&gt;This blog is called {blogTitle}&lt;/h1&gt;</programlisting>Now,
      you might want to extend the output by the blog author as well. To do
      this, you could repeat the above steps, but that would be quite
      inconvenient and hard to read.</para>

      <para>That's why the template language has a special syntax for object
      access, demonstrated below. A nicer way of expressing the above is the
      following:</para>

      <para><programlisting><lineannotation>This should go into the controller:
</lineannotation>$this-&gt;view-&gt;addVariable('blog', $blog);
<lineannotation>This should go into the template:</lineannotation>
&lt;h1&gt;This blog is called <emphasis>{blog.title}</emphasis>, written by <emphasis>{blog.author}</emphasis>&lt;/h1&gt;</programlisting>Instead
      of passing strings to the template, we are passing whole objects around
      now. To access certain properties of these objects, you can use the
      <emphasis>Object Accessors</emphasis>. By writing
      <code>{blog.title}</code>, the template engine will call a
      <code>getTitle()</code> method on the <code>blog</code> object, if it
      exists. Besides, you can use that syntax to traverse associative arrays
      and public properties.</para>

      <para><tip>
          <para>Deep nesting is supported: If you want to output the email
          address of the blog author, then you can use
          <code>{blog.author.email}</code>, which internally calls
          <code>$blog-&gt;getAuthor()-&gt;getEmail()</code>.</para>
        </tip></para>
    </section>

    <section>
      <title>Arrays</title>

      <para>Some view helpers, like the <code>SelectViewHelper</code> (which
      renders an HTML select dropdown box), need to get associative arrays as
      arguments (mapping from internal to displayed name). See the following
      example how this works:</para>

      <para><programlisting>&lt;f3:form.select options="{edit: 'Edit item', delete: 'Delete item'}" /&gt;</programlisting>The
      array syntax used here is very similar (if not equal) to the JSON object
      syntax. Thus, the left side of the associative array is used as key
      without any parsing, and the right side can be either:</para>

      <para><itemizedlist>
          <listitem>
            <para>a number</para>

            <para><programlisting>{a : 1,
 b : 2
}</programlisting></para>
          </listitem>

          <listitem>
            <para>a string; Needs to be in either single- or double quotes. In
            a double-quoted string, you need to escape the " with a \ in front
            (and vice versa for single quoted strings).</para>

            <para><programlisting>{a : 'Hallo',
 b : "Second string"
}</programlisting></para>
          </listitem>

          <listitem>
            <para>a nested array</para>

            <para><programlisting>{a : {
    a1 : "bla1",
    a2 : "bla2"
  },
 b : "hallo"
}</programlisting></para>
          </listitem>

          <listitem>
            <para>a variable reference</para>

            <para><programlisting>{blogTitle : blog.title,
 blogObject: blog
}</programlisting>Here, you have all the possibilities the object accessors
            have.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section>
    <title>Passing data to templates</title>

    <para></para>
  </section>

  <section>
    <title>Layouts</title>

    <para>In almost all web applications, there are many similarities between
    each page. Usually, there are common templates, menu structures,
    ...</para>

    <para>To make this possible in Fluid, we created a layout system, which we
    will introduce in this chapter.</para>

    <section>
      <title>Writing a layout</title>

      <para>Every layout is placed in the
      <filename>Resources/Template/layout</filename> directory, and has the
      file ending <filename>.xhtml</filename>. A layout is a normal Fluid
      template file, except there are some parts where the actual content of
      the target page should be inserted.</para>

      <para>Below is an example layout:</para>

      <para><programlisting>{namespace F3=F3::Fluid::ViewHelpers}
&lt;html&gt;
&lt;head&gt;&lt;title&gt;My fancy web application&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div id="menu"&gt;... menu goes here ...&lt;/div&gt;
&lt;div id="content"&gt;<emphasis>&lt;f3:render section="content" /&gt;</emphasis>&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>The only speciality of this layout is the
      <code>&lt;f3:render section="..."&gt;</code>-tag. With this tag, a
      special section is rendered. However, as we are in a layout currently,
      the section from the target template is rendered, and not the section
      from the layout file.</para>
    </section>

    <section>
      <title>Using a layout</title>

      <para>Using a layout involves two steps:</para>

      <para><itemizedlist>
          <listitem>
            <para>Declare which layout to use: <code>&lt;f3:layout name="..."
            /&gt;</code> can be written anywhere on the page - the given name
            references the layout.</para>
          </listitem>

          <listitem>
            <para>Define the sections as used by the layout:
            <code>&lt;f3:section
            name="content"&gt;...&lt;/f3:section&gt;</code></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section>
    <title>Writing your own view helper</title>

    <para>View Helpers are standard PHP classes, each extending
    <classname>F3::Fluid::Core::AbstractViewHelper</classname>. You need to
    implement at least two methods to write a view helper:</para>

    <para><itemizedlist>
        <listitem>
          <para><methodname>initializeArguments()</methodname>: Inside this
          method, you need to register all the arguments you expect the view
          helper to use.</para>
        </listitem>

        <listitem>
          <para><methodname>render()</methodname>: Render the view helper and
          return the result.</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>Initializing arguments</title>

      <para>As previously mentioned, initializing arguments takes place inside
      the <methodname>initializeArguments()</methodname> method. Call
      <code>$this-&gt;registerArgument(...)</code> once for each
      argument.</para>

      <para>See the section about the
      <classname>TagBasedViewHelper</classname> for some more
      possibilities.</para>
    </section>

    <section>
      <title>Rendering the view helper</title>

      <para>The rendering of the view helper is being triggered by the
      render() method of it. It is expected to return the rendered content as
      a string.</para>

      <para>You have the following possibilities to access the environment
      when rendering your view helper:</para>

      <para><itemizedlist>
          <listitem>
            <para><code>$this-&gt;arguments</code> is a read-only associative
            array where you will find the values for all arguments you
            registered previously.</para>
          </listitem>

          <listitem>
            <para><code>$this-&gt;renderChildren()</code> renders everything
            between the opening and closing tag of the view helper and returns
            the rendered result.</para>
          </listitem>

          <listitem>
            <para><code>$this-&gt;variableContainer</code> is an instance of
            <classname>F3::Fluid::Core::VariableContainer</classname>, so you
            have access to all variables registered in the template at the
            given point.</para>

            <para>Additionally, you can add variables to the container with
            <code>$this-&gt;variableContainer-&gt;add($identifier,
            $value)</code>, but you have to make sure that you
            <emphasis>remove every variable you added</emphasis> again! This
            is a security measure against side-effects.</para>

            <para>It is as well not possible to add a variable to the
            VariableContainer if a variable of the same name already exists -
            again to prevent side effects and scope problems.</para>
          </listitem>
        </itemizedlist>An example of the <methodname>render()</methodname>
      method for a loop:</para>

      <para><programlisting>public function render() {
  $out = '';
  foreach ($this-&gt;arguments['each'] as $singleElement) {
    $this-&gt;variableContainer-&gt;add($this-&gt;arguments['as'], $singleElement);
    $out .= $this-&gt;renderChildren();
    $this-&gt;variableContainer-&gt;remove($this-&gt;arguments['as']);
  }
  return $out;
}</programlisting>The above example demonstrates how we add a variable, render
      all children (everything between the opening and closing tag), and
      remove the variable again to prevent side-effects.</para>

      <para>In some cases, however, the view helper needs to access more
      properties of its environment, and that's where facets come into
      play.</para>
    </section>

    <section>
      <title>Facets</title>

      <para>The possibilities you get when you base your view helper on
      <classname>AbstractViewHelper</classname> should be enough for most use
      cases - however, there are some cases when the view helper needs to
      interact in a special way with its surroundings - an example is the
      "if/else" view helper group.</para>

      <para>If a view helper chooses to implement a certain facet (this means
      it must implement a certain Facet Interface), it gets special access to
      its surroundings.</para>

      <para>Sometimes, the view helper needs direct access to its child nodes
      - as it does not want to render all of its children, but only a subset.
      For this to work the
      <interfacename>SubNodeAccessInterface</interfacename> has been
      introduced.</para>

      <section>
        <title>SubNodeAccess Facet</title>

        <para>Let's take if/then/else as an example and start with two
        examples how this view helper is supposed to work:</para>

        <para><programlisting>&lt;f3:if condition="..."&gt;
   This text should only be rendered if the condition evaluates to TRUE.
&lt;/f3:if&gt;</programlisting>This above case is the most simple case,
        however, we want to support if/else as well:</para>

        <para><programlisting>&lt;f3:if condition="..."&gt;
   &lt;f3:then&gt;If condition evaluated to TRUE, this should be rendered&lt;/f3:then&gt;
   &lt;f3:else&gt;condition was FALSE -&gt; we render the else part.&lt;/f3:else&gt;
&lt;/f3:if&gt;</programlisting>To implement the functionality of the
        <code>&lt;f3:if&gt;</code> view helper, a standard
        <code>$this-&gt;renderChildren()</code> will not be sufficent, as the
        <code>if</code>-Tag has no control whether the
        <code>&lt;f3:then&gt;</code> or <code>&lt;f3:else&gt;</code> is
        rendered. Thus, the <code>&lt;f3:if&gt;</code> tag needs more
        information about its environment, namely it needs access to its
        subnodes in the syntax tree.</para>

        <para>To make this work, the <code>&lt;f3:if&gt;</code>-tag implements
        the
        <interfacename>F3::Fluid::Core::Facets::SubNodeAccessInterface</interfacename>,
        which consists of a <methodname>setChildren(array
        $childNodes)</methodname> method being called before the
        <methodname>render()</methodname> method is triggered. Then, it can
        evaluate the sub nodes inside the <methodname>render()</methodname>
        method, and decide which part of the subnodes it will render based on
        the condition.</para>
      </section>

      <section>
        <title>PostParse Facet</title>

        <para></para>
      </section>
    </section>
  </section>

  <section>
    <title>Standard View Helper Library</title>

    <para></para>
  </section>
</chapter>